# Coding Interview University

> Първоначално създадох това като кратък списък с теми за учене, за ставане на софтуерен инженер, но то се разрасна до този огромен списък, който виждате в момента. След като преминах през този учебен план, [бях нает като софтуерен инженер в Amazon](https://startupnextdoor.com/ive-been-acquired-by-amazon/?src=ciu)! Най-вероятно няма да Ви се налага да учите колкото мен, но все пак всичко, от което се нуждаете е тук.
>
> Учих по около 8-12 часа на ден за няколко месеца. Това е историята ми: [Why I studies full-time for 8 months for a Google interview](https://medium.freecodecamp.org/why-i-studied-full-time-for-8-months-for-a-google-interview-cc662ce9bb13)
>
> **Моля обърнете внимание:** Няма да Ви се налага да учите колкото мен. Загубих много време, учейки неща, които нямах нужда да знам. Може да прочетете повече за това надолу. Ще Ви помогна да достигнете до крайната цел без да прахосвате скъпото си време.
>
> Темите, изредени тук, ще Ви подготвят добре за техническо интервю за почти всяка една компания, включително гигантите Amazon, Facebook, Google и Microsoft
>
> _Пожелавам Ви успех!_

<details>
<summary>Преводи:</summary>

-   [中文版本](translations/README-cn.md)
-   [Tiếng Việt - Vietnamese](translations/README-vi.md)
-   [Español](translations/README-es.md)
-   [Português Brasileiro](translations/README-ptbr.md)
-   [Polish](translations/README-pl.md)
-   [繁體中文](translations/README-tw.md)
-   [Japanese (日本語)](translations/README-ja.md)
-   [Russian](translations/README-ru.md)
-   [German](translations/README-de.md)
-   [Bahasa Indonesia](translations/README-id.md)
-   [ខ្មែរ - Khmer](translations/README-kh.md)
-   [Uzbek](translations/README-uz.md)

</details>

<details>
<summary>Текущи преводи:</summary>

-   [हिन्दी](https://github.com/jwasham/coding-interview-university/issues/81)
-   [עברית](https://github.com/jwasham/coding-interview-university/issues/82)
-   [Arabic](https://github.com/jwasham/coding-interview-university/issues/98)
-   [Turkish](https://github.com/jwasham/coding-interview-university/issues/90)
-   [French](https://github.com/jwasham/coding-interview-university/issues/89)
-   [Українська](https://github.com/jwasham/coding-interview-university/issues/106)
-   [Korean(한국어)](https://github.com/jwasham/coding-interview-university/issues/118)
-   [Telugu](https://github.com/jwasham/coding-interview-university/issues/117)
-   [Urdu](https://github.com/jwasham/coding-interview-university/issues/519)
-   [Thai](https://github.com/jwasham/coding-interview-university/issues/156)
-   [Greek](https://github.com/jwasham/coding-interview-university/issues/166)
-   [Malayalam](https://github.com/jwasham/coding-interview-university/issues/239)
-   [Bulgarian](https://github.com/jwasham/coding-interview-university/issues/1032)

</details>

<div align="center">
	<hr />
    <p>
        <a href="https://github.com/sponsors/jwasham"><strong>Become a sponsor</strong> and support Coding Interview University!</a>
    </p>
    <p>
        <strong>Special thanks to:</strong>
    </p>
    <p>
        <a href="https://oss.capital/">
            <div>
                <img src="https://d3j2pkmjtin6ou.cloudfront.net/sponsors/oss-capital.svg" width="350" alt="OSS Capital">
            </div>
            <div>
                <sup><strong>Founded in 2018, OSS Capital is the first and only venture capital platform focused<br>exclusively on supporting early-stage COSS (commercial open source) startup founders.</strong></sup>
            </div>
        </a>
    </p>
    <br />
    <p>
        <a href="https://www.gitpod.io/?utm_campaign=jwasham&utm_medium=referral&utm_content=coding-interview-university&utm_source=github">
            <div>
                <img src="https://d3j2pkmjtin6ou.cloudfront.net/sponsors/gitpod-logo-light-theme.svg" width="300" alt="Gitpod">
            </div>
            <div>
                <p>
                    <strong>Dev environments built for the cloud</strong>
                </p>
            </div>
            <div>
                <sup>Natively integrated with GitLab, GitHub, and Bitbucket, Gitpod automatically and continuously prebuilds dev environments for all your branches. As a result team members can instantly start coding with fresh dev environments for each new task - no matter if you are building a new feature, want to fix a bug, or work on a code review.</sup>
            </div>
        </a>
    </p>
    <hr />
</div>

## Какво е това?

![Coding at the whiteboard - from HBO's Silicon Valley](https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png)

Това е моят многомесечен план за ставане на софтуерен инженер към голяма компания.

**Изисквания:**

-   Малко опит с програмиране (променливи, цикли, методи/функции и т.н)
-   Търпение
-   Време

Забележете, че това е учебен план за **софтуерно инженерство**, а не уеб разработка. Големите компании като Google, Amazon, Facebook и Microsoft различават софтуерното инженерство и уеб разработката. Amazon, например, имат Frontend инженери (FEE) и Software Development инженери (SDE). Това са 2 отделни позиции и интервютата за тях няма да са еднакви, тъй като всяка една от тях има своите специфики. Тези компании изискват знания по компютърни науки за позиции свързани с софтуерно инженерство/разработка

---

## Съдържание

### Учебният план

-   [Какво е това?](#какво-е-това)
-   [Защо да го ползвате?](#защо-да-го-ползвате)
-   [Как да го ползвате?](#как-да-го-ползвате)
-   [Не мислете, че не сте достатъчно умни](#не-мислете-че-не-сте-достатъчно-умни)
-   [Бележка за видео ресурсите](#бележка-за-видео-ресурсите)
-   [Изберете език за програмиране](#изберете-език-за-програмиране)
-   [Книги за структури от данни и алгоритми](#книги-за-структури-от-данни-и-алгоритми)
-   [Книги за подготовка за интервю](#книги-за-подготовка-за-интервю)
-   [Не повтаряйте грешките ми](#не-повтаряйте-грешките-ми)
-   [Какво няма да намерите тук](#какво-няма-да-намерите-тук)
-   [Дневния план](#дневния-план)
-   [Подготовка за въпроси за програмиране](#подготовка-за-въпроси-за-програмиране)
-   [Задачи по програмиране](#задачи-по-програмиране)

### Теми за учене

-   [Алгоритмична сложност / Big-O / Асимптотичен анализ](#алгоритмична-сложност--big-o--асимптотичен-анализ)
-   [Структури от данни](#структури-от-данни)
    -   [Масиви (Arrays)](#масиви)
    -   [Свързани списъци(Linked Lists)](#свързани-списъци)
    -   [Стек (Stack)](#стек)
    -   [Опашка (Queue)](#опашка)
    -   [Хеш таблици (Hash table)](#хеш-таблици)
-   [Повече знания](#повече-знания)
    -   [Двоично търсене (Binary search)](#двоично-търсене)
    -   [Побитови операции (Bitwise operations)](#побитови-операции)
-   [Дървета](#дървета)
    -   [Дървета - бележки & основи](#дървета---бележки--основи)
    -   [Дървета за двоично търсене: BSTs (Binary search trees)](#дървета-за-двоично-търсене-bsts)
    -   [Heap / Priority Queue / Binary Heap](#heap--priority-queue--binary-heap)
    -   балансирани дървета за търсене (основна концепция, без детайли)
    -   обхождане: preorder, inorder, postorder, BFS, DFS
-   [Сортиране (Sorting)](#сортиране)
    -   selection
    -   insertion
    -   heapsort
    -   quicksort
    -   merge sort
-   [Графи (Graphs)](#графи)
    -   directed
    -   undirected
    -   adjacency matrix
    -   adjacency list
    -   traversals: BFS, DFS
-   [Още повече знания](#още-повече-знания)
    -   [Рекурсия (Recursion)](#рекурсия)
    -   [Динамично програмиране (Dynamic programming)](#динамично-програмиране)
    -   [Design Patterns](#design-patterns)
    -   [Комбинаторика & вероятности](#комбинаторика--вероятности)
    -   [NP, NP-Complete and Approximation Algorithms](#np-np-complete-and-approximation-algorithms)
    -   [Как компютрите обработват една програма](#как-компютрите-обработват-една-програма)
    -   [Кеширане (Caches)](#кеширане)
    -   [Процеси и нишки](#процеси-и-нишки)
    -   [Тестване (Testing)](#тестване)
    -   [String searching & manipulations](#string-searching--manipulations)
    -   [Tries](#tries)
    -   [Floating Point Numbers](#floating-point-numbers)
    -   [Уникод (Unicode)](#уникод)
    -   [Endianness](#endianness)
    -   [Мрежи (Networking)](#мрежи)
-   [Последен преглед](#последен-преглед)

### Как да спечелите позицията

-   [Актуализирайте резюмето си](#актуализирайте-резюмето-си)
-   [Намерете позиция](#намерете-позиция)
-   [Процесът на интервюто & обща подготовка](#процесът-на-интервюто--обща-подготовка)
-   [Мислете за това, когато дойде интервюто](#мислете-за-това-когато-дойде-интервюто)
-   [Подгответе въпроси за интервюиращия](#подгответе-въпроси-за-интервюиращия)
-   [След като са Ви наели](#след-като-са-ви-наели)

**---------------- Всичко оттук надолу е по желание ----------------**

### Допълнителни теми и ресурси

-   [Допълнителни книги](#допълнителни-книги)
-   [Системен дизайн, мащабируемост, обработка на данни](#системен-дизайн-мащабируемост-обработка-на-данни) (ако имате над 4 години опит)
-   [Additional Learning](#additional-learning)
    -   [Компилатори](#компилатори)
    -   [Emacs and vi(m)](#emacs-and-vim)
    -   [Unix command line tools](#unix-command-line-tools)
    -   [Information theory](#information-theory-videos)
    -   [Паритет & код на Хаминг](#паритет--код-на-хаминг)
    -   [Ентропия](#ентропия)
    -   [Криптография](#криптография)
    -   [Компресия](#компресия)
    -   [Компютърна сигурност](#компютърна-сигурност)
    -   [Garbage collection](#garbage-collection)
    -   [Паралелно програмиране](#паралелно-програмиране)
    -   [Системи за съобщения, сериализация и queueing](#системи-за-съобщения-сериализация-и-queueing)
    -   [A\*](#a)
    -   [Fast Fourier Transform](#fast-fourier-transform)
    -   [Bloom Filter](#bloom-filter)
    -   [HyperLogLog](#hyperloglog)
    -   [Locality-Sensitive Hashing](#locality-sensitive-hashing)
    -   [van Emde Boas Trees](#van-emde-boas-trees)
    -   [Разширени структури от данни](#разширени-структури-от-данни)
    -   [Балансирани дървета за търсене](#балансирани-дървета-за-търсене)
        -   AVL trees
        -   Splay trees
        -   Red/black trees
        -   2-3 search trees
        -   2-3-4 Trees (aka 2-4 trees)
        -   N-ary (K-ary, M-ary) trees
        -   B-Trees
    -   [k-D Trees](#k-d-trees)
    -   [Skip lists](#skip-lists)
    -   [Мрежови потоци](#мрежови-потоци)
    -   [Disjoint Sets & Union Find](#disjoint-sets--union-find)
    -   [Математика за бърза обработка](#математика-за-бърза-обработка)
    -   [Treap](#treap)
    -   [Линейно програмиране](#линейно-програмиране)
    -   [Geometry, Convex hull](#geometry-convex-hull-videos)
    -   [Дискретна математика](#дискретна-математика)
    -   [Machine Learning](#machine-learning)
-   [Допълнителни детайли по някои теми](#допълнителни-детайли-по-някои-теми)
-   [Видео серии](#видео-серии)
-   [Курсове по компютърни науки](#курсове-по-компютърни-науки)
-   [Papers](#papers)

---

## Защо да го ползвате?

Ако искате да работите като софтуерен инженер в голяма компания, това са нещата, които трябва да знаете.

Ако също като мен не сте учили компютърни науки в университет това ще Ви помогне да наваксате и ще Ви спести години.

Когато започнах този проект не знаех какво е стек или опашка, нямах представа какво е Big-O, не знаех нищо за дървета или как да обхождам графи. Ако трябваше да напиша сортиращ алгоритъм мога да Ви кажа, че бих се справил ужасно. Всяка от структурите от данни, които бях използвал досега бяха имплементирани в езика, който ползвах и нямах представа как работят реално. Никога не ми се беше налагало да управлявам памет освен ако някой от процесите, които бях пуснал не връщаха грешка "out of memory"- тогава се налагаше да търся заобиколен път. Бях ползвал хиляди асоциативни масиви и многоизмерни масиви няколко пъти, но никога преди не бях имплементирал структури от данни от нулата.

Планът е дълъг. Може да Ви отнеме месеци. Ако вече сте запознати с повечето от темите ще Ви отнеме многи по-малко

## Как да го ползвате

Всичко надолу е само схематично изложение и трябва да преминете през темите от горе до долу.

## Не мислете, че не сте достатъчно умни

-   Успешните софтуерни инженери са умни, но много имат чувството, че не са достатъчно умни
-   [Митът за гениалния програмист](https://www.youtube.com/watch?v=0SARbwvhupQ)
-   [Опасно е да сте сами: битката с невидимите чудовища в IT](https://www.youtube.com/watch?v=1i8ylq4j_EY)

## Бележка за видео ресурсите

Някои видеа са достъпни само след записване в курс на Coursera или EdX- т.нар. MOOCs. Понякога се налага да изчакате няколко месеца, за да стартира ново издание на курса, така че няма да имате достъп до тях.

Би било чудесно такива ресурси да бъдат заменену с безплатни и винаги-достъпни публични източници като YouTube видеота (по възможност университетски лекции), за да могат всички да учат навсякъде и по всяко време, а не само когато даден курс върви в момента.

## Изберете език за програмиране

Трябва да изберете език за програмиране за интервютата на които ще се явявате, но също така трябва да изберете език, който можете да ползвате за учене на концепции от компютърните науки.

Желателно е този език да е един и същ, така ще Ви се налага да владеете само един език.

### За този учебен план

Когато преминавах през учебния план ползвах 2 езика за по-голямата част от нещата: C и Python

-   C: Език на много ниско ниво. Дава Ви възможност да се справяте с пойнтъри и управляване на паметта, за да разберете структурите от данни и алгоритмите на много дълбоко ниво. В езици за програмиране на по-високо ниво тези неща са скрити от Вас. В ежедневната работа това е прекрасно, но когато се учите как тези структури от данни работят е хубаво да усещате как става всичко.
    -   C е навсякъде. Ще виждате примери в книги, лекции, видеа _навсякъде_ докато учите.
    -   [The C Programming Language, Vol 2](https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628)
        -   Това е кратка книга, но ще Ви даде добра представа за езика и с малко упражнения бързо ще имате добро владение над него. Ако разбирате C значи разбирате как програмите и паметта работят.
        -   Не трябва да се зачитате много надълбоко в книгата (или дори да я прочитате докрай). Нужно е само да сте уверени в способността си да четете и пишете в C.
        -   [Отговори на въпросите в книгата](https://github.com/lekkas/c-algorithms)
-   Python: модерен и много експресивен. Научих го защото е наистина много полезен и ми позволява да пиша по-малко код когато съм на интервю.

Това е моя личен избор. Вие можете да изберете каквото пожелаете, разбира се.

Може да не Ви трябват, но ето някои сайтове за учене на нов език:

-   [Exercism](https://exercism.org/tracks)
-   [Codewars](http://www.codewars.com)
-   [Codility](https://codility.com/programmers/)
-   [HackerEarth](https://www.hackerearth.com/)
-   [Sphere Online Judge (spoj)](http://www.spoj.com/)
-   [Codechef](https://www.codechef.com/)
-   [Codeforces](https://codeforces.com/)

### За интервюто Ви по програмиране

Може да изберете език, в който се чувствате комфортно за интервюто Ви, но за големите компании това са най-добрите опции:

-   C++
-   Java
-   Python

Може да ползвате и тези, но поразгледайте преди това, защото може да има уловки:

-   JavaScript
-   Ruby

Това е статия, която написах за избирането на език за вашето интервю:
[Pick One Language for the Coding Interview](https://startupnextdoor.com/important-pick-one-language-for-the-coding-interview/).
Това е оригиналната статия, на която базирах моя пост: http://blog.codingforinterviews.com/best-programming-language-jobs/

Трябва да се чувствате много удобно с вашия език и да сте знаещи.

Повече за вариантите:

-   [Изберете правилния език за вашето интервю по програмиране](http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/)

[Вижте ресурси за специфични езици тук](programming-language-resources.md)

## Книги за структури от данни и алгоритми

Тази книга ще положи вашата основа в компютърните науки.

Просто изберете една в език, с който ще се чувствате комфортно. Ще трябва да четете и да пишете код доста.

### C

-   [Algorithms in C, Parts 1-5 (Bundle), 3rd Edition](https://www.amazon.com/Algorithms-Parts-1-5-Bundle-Fundamentals/dp/0201756080)
    -   Основни познания, структури от данни, сортиране, търсене и алгоритми за графи

### Python

-   [Data Structures and Algorithms in Python](https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/)
    -   от Goodrich, Tamassia, Goldwasser
    -   Тази книга ми допадна много. Покрива всичко и още нещо
    -   'Питоничен' код
    -   Докладът ми за тази книга: https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/

### Java

Изборът е ваш:

-   Goodrich, Tamassia, Goldwasser
    -   [Data Structures and Algorithms in Java](https://www.amazon.com/Data-Structures-Algorithms-Michael-Goodrich/dp/1118771338/)
-   Sedgewick and Wayne:
    -   [Algorithms](https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/)
    -   Безплатен курс в Coursera, който покрива материала от книгата (воден от писателите!):
        -   [Algorithms I](https://www.coursera.org/learn/algorithms-part1)
        -   [Algorithms II](https://www.coursera.org/learn/algorithms-part2)

### C++

Изборът е ваш:

-   Goodrich, Tamassia, and Mount
    -   [Data Structures and Algorithms in C++, 2nd Edition](https://www.amazon.com/Data-Structures-Algorithms-Michael-Goodrich/dp/0470383275)
-   Sedgewick and Wayne
    -   [Algorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching](https://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882/)
    -   [Algorithms in C++ Part 5: Graph Algorithms](https://www.amazon.com/Algorithms-Part-Graph-3rd-Pt-5/dp/0201361183/)

## Книги за подготовка за интервю

Няма нужда да купувате цял куп от тези книги. Честно казано "Cracking the Coding Interview" най-вероятно ще Ви бъде достатъчна, но аз си купих повече, за да се упражня по-добре. Но аз винаги правя прекалено много.

Купих тези двете, дадоха ми предостатъчно упражнение.

-   [Programming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition](https://www.amazon.com/Programming-Interviews-Exposed-Through-Interview/dp/111941847X/)
    -   Отговори в C++ и Java
    -   Това е добра подготовка за "Cracking the Coding Interview"
    -   Не е прекалено сложна. Повечето проблеми са по-лесни от тези, които ще срещнете на интервю (от това, което аз съм прочел)
-   [Cracking the Coding Interview, 6th Edition](http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/)
    -   отговори в Java

### Ако имате изобилие от време:

Изберете една:

-   [Elements of Programming Interviews (C++ version)](https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836)
-   [Elements of Programming Interviews in Python](https://www.amazon.com/Elements-Programming-Interviews-Python-Insiders/dp/1537713949/)
-   [Elements of Programming Interviews (Java version)](https://www.amazon.com/Elements-Programming-Interviews-Java-Insiders/dp/1517435803/) - [Companion Project - Method Stub and Test Cases for Every Problem in the Book](https://github.com/gardncl/elements-of-programming-interviews)

## Не повтаряйте грешките ми

Този списък се разрасна с времето и да, нещата излязоха извън контрол.

Споделям някои от грешките, които направих, за да имате по-добро преживяване и за да си спестите месеци с време.

### 1. Няма да запомните всичко

Изгледах часове с клипове и водих записки за всичко, но след месеци имаше доста неща, които не си спомнях. Прекарах 3 дена преразглеждайки бележките си, за да си припомня някои неща. Не се нуждаех от всичките тези знания.

Моля, прочетете това, за да не повторите грешките миЛ

[Да запазваме знания свързани с компютърни науки](https://startupnextdoor.com/retaining-computer-science-knowledge/).

### 2. Използвайте флаш карти

За да се справя с проблема си направих малък сайт за флаш карти, където можех да добавям 2 вида карти: общи и такива с код. Всяка карта има ралично форматиране. Направих сайта mobile-first, за да мога да ги разглеждам от телефона или таблета си, навсякъде където съм.

Направете свои безплатно:

-   [Flashcards site repo](https://github.com/jwasham/computer-science-flash-cards)

**НЕ ПРЕПОРЪЧВАМ да ползвате моите флаш карти.** Има прекалено много и някои от тях съдържат информация, която не е нужно да знаете.

Но ако не искате да ме послушате, ето:

-   [Базата ми от данни с флаш карти (1200 карти)](https://github.com/jwasham/computer-science-flash-cards/blob/main/cards-jwasham.db):
-   [Базата ми от данни с флаш карти (екстремно - 1800 карти)](https://github.com/jwasham/computer-science-flash-cards/blob/main/cards-jwasham-extreme.db):

Забележете, че аз прекалих и имам карти, които покриват всичко от assembly language и Python Trivia до machine learning и статистика. Прекалено много е за това, което се изисква.

**Бележка за флаш картите:** Първия път когато видите, че знаете отговора, не я отбелязвайте като "позната". Трябва да видите същата карта и отговора няколко пъти, преди наистина да знаете отговора. Повторението ще накара мозъка Ви наистина да запамети знанието.

### 3. Решавайте задачи от интервюта по програмиране докато учите

ТОВА Е МНОГО ВАЖНО.

Почнете да решавате задачи от интервюта по програмиране докато учите структури от данни и алгоритми.

Трябва да прилагате това, което учите като решавате задачи иначе ще забравите. Аз направих тази грешка.

Когато сте научили някоя тема и се чувствате що годе комфортно с нея, например **linked lists**:

1. Отворете една от [книгите за интервю за програмиране](#книги-за-подготовка-за-интервю) (или един от сайтовете със задачи, изредени по-долу)
1. Решете 2-3 задачи свързани с linked lists.
1. Продължете към следващата тема.
1. По-късно се върнете и отново решете 2-3 задачи свързани с linked lists.
1. Повтаряйте това с всяка нова тема, която учите.

**Продължавайте да решавате задачи докато учите всичко това, а не след това.**

Няма да ви наемат за знанията, които имате, а за това как ги прилагате.

Има много ресурси свързани с това надолу. Продължавайте да четете.

### 4. Фокусирайте се

Има много неща, които могат да отвлекат вниманието Ви и да Ви загубят ценно време. Да сте концентрирани е трудно. Пуснете си музика без текст и ще можете да се фокусирате сравнително добре.

## Какво няма да намерите тук

Това са широко разпространени технологии, но не и част от учебния план:

-   SQL
-   Javascript
-   HTML, CSS, и други front-end технологии

## Дневния план

Този курс преминава през множество от теми. Всяка от тях най-вероятно ще Ви отнеме няколко дена или дори седмица, или повече. Зависи от графика Ви.

Всеки ден взимайте следващата тема в списъка, изгледайте няколко клипа по тази тема и след това напишете имплементацията на въпросната структура от данни или алгоритъм в езика за програмиране, който сте избрали за този курс.

Можете да видите моя код тук:

-   [C](https://github.com/jwasham/practice-c)
-   [C++](https://github.com/jwasham/practice-cpp)
-   [Python](https://github.com/jwasham/practice-python)

Не е нужно да помните всеки алгоритъм наизуст. Необходимо е просто да ги разбирате достатъчно добре, за да можете да напишете собствена имплементация.

## Подготовка за въпроси за програмиране

    Защо това е тук? Аз не съм готов да се явя на интервю.

[Тогава се върни и прочети това.](#3-решавайте-задачи-от-интервюта-по-програмиране-докато-учите)

Защо трябва да се упражнявате да решавате задачи по програмиране:

-   Разпознаване на проблеми и знанието кога и къде да ползвате дадена структура от данни или алгоритъм
-   Събиране на изискванията за задачата
-   Изговаряне на мислите Ви докато решавате както ще правите на интервюто
-   Писане на код върху дъска или лист хартия вместо на компютър
-   Намиране на времевата и пространствената сложност на решенията Ви (вижте Big-O надолу)
-   Тестване на решенията Ви

Пишете код на дъска или лист хартия вместо на компютър. Тествайте с няколко различни входни данни. След това го напишете и тествайте на компютър.

Ако нямате дъска за писане вкъщи можете да си купите голям тефтер от магазин за арт материали. Можете просто да седите на дивана и да се упражнявате. Това е моята "дъска за дивана". Добавих химикала към снимката за съпоставка на размера. Ако използвате химикал бързо ще ви се поиска да можеше да триете написаното- бързо става мазало. **Аз ползвам молив и гума.**

![моята дъска за дивана](https://d3j2pkmjtin6ou.cloudfront.net/art_board_sm_2.jpg)

**Когато се упражнявате да решавате задачи по програмиране не трябва да помните решенията наизуст.**

## Задачи по програмиране

Не забравяйте основните книги за подготовка за интервюто по програмиране [тук](#книги-за-подготовка-за-интервю)

Решаване на задачи:

-   [Как да намерим решение](https://www.topcoder.com/community/competitive-programming/tutorials/how-to-find-a-solution/)
-   [Как да направим дисекция на условие на задача от Topcoder](https://www.topcoder.com/community/competitive-programming/tutorials/how-to-dissect-a-topcoder-problem-statement/)

Клипове за задачи от интервюта по програмиране:

-   [IDeserve (88 клипа)](https://www.youtube.com/playlist?list=PLamzFoFxwoNjPfxzaWqs7cZGsPYy0x_gI)
-   [Tushar Roy (5 плейлисти)](https://www.youtube.com/user/tusharroy2525/playlists?shelf_id=2&view=50&sort=dd)
    -   Супер за насоки за решаване на задачи
-   [Nick White - LeetCode Solutions (187 клипа)](https://www.youtube.com/playlist?list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-)
    -   Добро обяснение на решението и кода
    -   Можете да изгледате няколко клипа в малък прозорец от време
-   [FisherCoder - LeetCode Solutions](https://youtube.com/FisherCoder)

Сайтове със задачи:

-   [LeetCode](https://leetcode.com/)
    -   Любимият ми сайт със задачи. Струва си парите за абонамент за времето, в което ще се подготвяте.
    -   Вижте клиповете на Nick White и FisherCoder Videos по-горе за насоки със някои задачи.
-   [HackerRank](https://www.hackerrank.com/)
-   [TopCoder](https://www.topcoder.com/)
-   [Geeks for Geeks](https://practice.geeksforgeeks.org/explore/?page=1)
-   [InterviewBit](https://www.interviewbit.com/)
-   [Project Euler](https://projecteuler.net/)

## Да започваме

Добре, стига сме говорили, нека да учим!

Но не забравяйте да решавате задачи от източниците по-горе докато учите!

## Алгоритмична сложност / Big-O / Асимптотичен анализ

-   Няма нищо за имплементация тук, единствено ще гледате клипове и ще си водите записки! Йей!
-   Има доста клипове тук. Просто изгледайте достатъчно докато не го разберете. Винаги можете да се върнете обратно и да преговорите.
-   Не се притеснявайте ако не разбирате всичката математика, която стои отзад.
-   Трябва просто да можете да изразите сложността на даден алгоритъм чрез Big-O
-   [ ] [Harvard CS50 - Asymptotic Notation (клип)](https://www.youtube.com/watch?v=iOq5kSKqeR4)
-   [ ] [Big O Notations (общ наръчник) (клип)](https://www.youtube.com/watch?v=V6mKVRU1evU)
-   [ ] [Big O Notation (и Omega, и Theta) - най-доброто математично обяснение (клип)](https://www.youtube.com/watch?v=ei-A_wy5Yxw&index=2&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN)
-   [ ] Skiena:
    -   [клип](https://www.youtube.com/watch?v=gSyDMtdPNpU&index=2&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b)
    -   [slides](https://archive.org/details/lecture2_202008)
-   [ ] [UC Berkeley Big O (клип)](https://archive.org/details/ucberkeley_webcast_VIS4YDpuP98)
-   [ ] [Амортизиран анализ (клип)](https://www.youtube.com/watch?v=B3SpQZaAZP4&index=10&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN)
-   [ ] TopCoder (includes recurrence relations and master theorem):
    -   [Computational Complexity: Section 1](https://www.topcoder.com/community/competitive-programming/tutorials/computational-complexity-section-1/)
    -   [Computational Complexity: Section 2](https://www.topcoder.com/community/competitive-programming/tutorials/computational-complexity-section-2/)
-   [ ] [Пищови](http://bigocheatsheet.com/)

Е, това е достатъчно за тази тема.

Когато четете "Cracking the Coding Interview" ще срещнете главата, която разглежда тази тема. Накрая на главата има кратък тест, който проверява дали можете да намерите сложността на различни алгоритми. Това е супер преговор и тест.

## Структури от данни

-   ### Масиви

    -   [ ] За масивите:
        -   [Arrays (клип)](https://www.coursera.org/lecture/data-structures/arrays-OsBSF)
        -   [UC Berkeley CS61B - Linear and Multi-Dim Arrays (клип)](https://archive.org/details/ucberkeley_webcast_Wp8oiO_CZZE) (Start watching from 15m 32s)
        -   [Dynamic Arrays (клип)](https://www.coursera.org/lecture/data-structures/dynamic-arrays-EwbnV)
        -   [Jagged Arrays (клип)](https://www.youtube.com/watch?v=1jtrQqYpt7g)
    -   [ ] Имплементирайте вектор (променлив масив с автоматично преоразмеряване):
        -   [ ] Упражнявайте се да пишете код, ползвайки масиви и пойнтъри. Ползвайте пойнтъри за преместване към индекс вместо индексиране
        -   [ ] New raw data array with allocated memory
            -   can allocate int array under the hood, just not use its features
            -   start with 16, or if starting number is greater, use power of 2 - 16, 32, 64, 128
        -   [ ] size() - номер на елементите
        -   [ ] capacity() - номер на елементите, които може да побира
        -   [ ] is_empty()
        -   [ ] at(index) - връща елемента на дадения индекс, ако индекса е извън границите на масива връща грешка
        -   [ ] push(item)
        -   [ ] insert(index, item) - вкарва елемента на дадения елемент, измествайки съществуващия елемент на този индекс и всички елементи след него надясно
        -   [ ] prepend(item) - може да добавя елементи на индекс 0
        -   [ ] pop() - премахва елемент от края и връща стойността му
        -   [ ] delete(index) - изтрива елемента на дадения индекс и измества всички елементи след него наляво
        -   [ ] remove(item) - търси стойността на елемента и премахва всички индекси, които я съдържат
        -   [ ] find(item) - търси стойността на елемента и връща първия индекс, който я съдържа, или -1 ако няма такъв елемент
        -   [ ] resize(new_capacity) // private function
            -   когато достигнете максималния обем, преоразмерете като дублирате обема
            -   когато pop-вате елемент, ако обема на масива е 1/4 от капацитета му, преоразмерете масива наполовина
    -   [ ] Време
        -   O(1) за добавяне/премахване към края, индексиране или актуализиране
        -   O(n) за добавяне/премахване другаде
    -   [ ] Пространство
        -   contiguous in memory, so proximity helps performance
        -   нужно място = (капацитета на масива, който е >= n) \* размера на елемента, но дори 2n, пак е O(n)

-   ### Свързани списъци

    -   [ ] Описание:
        -   [ ] [Единично свързани списъци (клип)](https://www.coursera.org/lecture/data-structures/singly-linked-lists-kHhgK)
        -   [ ] [CS 61B - Linked Lists 1 (клип)](https://archive.org/details/ucberkeley_webcast_htzJdKoEmO0)
        -   [ ] [CS 61B - Linked Lists 2 (клип)](https://archive.org/details/ucberkeley_webcast_-c4I3gFYe3w)
    -   [ ] [Код в C (клип)](https://www.youtube.com/watch?v=QN6FPiD0Gzo) - не цялото видео, само частите за Node structs и алокация на памет
    -   [ ] Свързани списъци срещу масиви:
        -   [Core Linked Lists Vs Arrays (клип)](https://www.coursera.org/lecture/data-structures-optimizing-performance/core-linked-lists-vs-arrays-rjBs9)
        -   [Свързани списъци срещу масиви в истинския свят (клип)](https://www.coursera.org/lecture/data-structures-optimizing-performance/in-the-real-world-lists-vs-arrays-QUaUd)
    -   [ ] [Защо да избягваме свързаните списъци (клип)](https://www.youtube.com/watch?v=YQs6IC-vgmo)
    -   [ ] Аха: трябват Ви pointer to pointer знания:
            (за да можете да подавате pointer към функция, която може да промени адреса, към който сочи pointer-a)
            Тази страница служи само да схванете ptr to ptr. Не препоръчвам този стил на обхождане на списъка. Четливостта и поддържаемостта страдат заради хитрости.
        -   [Pointers to Pointers](https://www.eskimo.com/~scs/cclass/int/sx8.html)
    -   [ ] Имплементация:
        -   [ ] size() - връща броя на елементите
        -   [ ] empty() - булева стойност, връща true ако списъка е празен
        -   [ ] value_at(index) - връща стойността на n-тия елемент (почвайки от 0 за първия елемент)
        -   [ ] push_front(value) - добавя стойност към началото на списъка
        -   [ ] pop_front() - премахва първия елемент и връща стойността му
        -   [ ] push_back(value) - добавя елемент към края
        -   [ ] pop_back() - премахва последния елемент и връща стойността му
        -   [ ] front() - взима стойността на първия елемент
        -   [ ] back() - взима стойността на последния елемент
        -   [ ] insert(index, value) - вкарва елемента на дадения индекс, така че новия елемент да сочи към стария елемент на този индекс
        -   [ ] erase(index) - изтрива node-а на дадения индекс
        -   [ ] value_n_from_end(n) - връща стойността на node-а, седящ на позиция n от края на списъка
        -   [ ] reverse() - обръща списъка
        -   [ ] remove_value(value) - премахва първия елемент от списъка, съдържащ тази стойност
    -   [ ] Двойно свързан списък
        -   [Описание (клип)](https://www.coursera.org/lecture/data-structures/doubly-linked-lists-jpGKD)
        -   Няма нужда от имплементация

-   ### Стек

    -   [ ] [Стекове (клип)](https://www.coursera.org/lecture/data-structures/stacks-UdKzQ)
    -   [ ] Няма нужда да се имплементира. Имплементацията с масив е тривиална.

-   ### Опашка

    -   [ ] [Опашка (клип)](https://www.coursera.org/lecture/data-structures/queues-EShpq)
    -   [ ] [Circular buffer/FIFO](https://en.wikipedia.org/wiki/Circular_buffer)
    -   [ ] Имплементирайте със свързан списък с tail pointer:
        -   enqueue(value) - добавя стойност на опашката
        -   dequeue() - връща стойността и премахва най-предния елемент на опашката (front)
        -   empty()
    -   [ ] Имплементрайте с масив с фиксирана големина:
        -   enqueue(value) - добавя елемента в края на наличното пространство
        -   dequeue() - връща стойността и премахва най-предния елемент на опашката
        -   empty()
        -   full()
    -   [ ] Разход:
        -   лоша имплементация, ползвайки свързан списък където правим enqueue в началото и dequeue в края би била O(n)
            защото ще се нуждаете от предпоследния елемент, което ще предизвиква цялостно обхождане при всяко dequeue
        -   enqueue: O(1) (amortized, свъзран списък и масив [probing])
        -   dequeue: O(1) (свъзран списък и масив)
        -   empty: O(1) (свъзран списък и масив)

-   ### Хеш таблици

    -   [ ] Клипове:

        -   [ ] [Hashing with Chaining (клип)](https://www.youtube.com/watch?v=0M_kIqhwbFo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=8)
        -   [ ] [Table Doubling, Karp-Rabin (клип)](https://www.youtube.com/watch?v=BRO7mVIFt08&index=9&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb)
        -   [ ] [Open Addressing, Cryptographic Hashing (клип)](https://www.youtube.com/watch?v=rvdJDijO2Ro&index=10&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb)
        -   [ ] [PyCon 2010: The Mighty Dictionary (клип)](https://www.youtube.com/watch?v=C4Kc8xzcA68)
        -   [ ] [PyCon 2017: The Dictionary Even Mightier (клип)](https://www.youtube.com/watch?v=66P5FMkWoVU)
        -   [ ] [(Advanced) Randomization: Universal & Perfect Hashing (клип)](https://www.youtube.com/watch?v=z0lJ2k0sl1g&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=11)
        -   [ ] [(За напреднали) Perfect hashing (клип)](https://www.youtube.com/watch?v=N0COwN14gt0&list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&index=4)

    -   [ ] Онлайн курсовe:

        -   [ ] [Core Hash Tables (клип)](https://www.coursera.org/lecture/data-structures-optimizing-performance/core-hash-tables-m7UuP)
        -   [ ] [Data Structures (клип)](https://www.coursera.org/learn/data-structures/home/week/4)
        -   [ ] [Phone Book Problem (клип)](https://www.coursera.org/lecture/data-structures/phone-book-problem-NYZZP)
        -   [ ] Дистрибутирани хеш таблици:
            -   [Instant Uploads And Storage Optimization In Dropbox (клип)](https://www.coursera.org/lecture/data-structures/instant-uploads-and-storage-optimization-in-dropbox-DvaIb)
            -   [Distributed Hash Tables (клип)](https://www.coursera.org/lecture/data-structures/distributed-hash-tables-tvH8H)

    -   [ ] Имплементирайте с масив, ползвайки linear probing
        -   hash(k, m) - m е размера на хеш таблицата
        -   add(key, value) - ако ключа съществува актуализирайте стойността
        -   exists(key)
        -   get(key)
        -   remove(key)

## Повече знания

-   ### Двоично търсене
    -   [ ] [Binary Search (клип)](https://www.youtube.com/watch?v=D5SrAga1pno)
    -   [ ] [Binary Search (клип)](https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search)
    -   [ ] [детайли](https://www.topcoder.com/community/competitive-programming/tutorials/binary-search/)
    -   [ ] Имплементирайте:
        -   двоично търсене (на сортиран масив от integers)
        -   двоично търсене чрез рекурсия
-   ### Побитови операции
    -   [ ] [Bits cheat sheet](https://github.com/jwasham/coding-interview-university/blob/main/extras/cheat%20sheets/bits-cheat-sheet.pdf) - трябва да знаете доста от степените на 2 от (2^1 до 2^16 и 2^32)
    -   [ ] Бъдете сигурни, че разбирате добре битовата манипулация: &, |, ^, ~, >>, <<
        -   [ ] [думи](<https://en.wikipedia.org/wiki/Word_(computer_architecture)>)
        -   [ ] Добро въведение:
                [Bit Manipulation (клип)](https://www.youtube.com/watch?v=7jkIUgLC29I)
        -   [ ] [C Programming Tutorial 2-10: Bitwise Operators (клип)](https://www.youtube.com/watch?v=d0AwjSpNXR0)
        -   [ ] [Bit Manipulation](https://en.wikipedia.org/wiki/Bit_manipulation)
        -   [ ] [Bitwise Operation](https://en.wikipedia.org/wiki/Bitwise_operation)
        -   [ ] [Bithacks](https://graphics.stanford.edu/~seander/bithacks.html)
        -   [ ] [The Bit Twiddler](https://bits.stephan-brumme.com/)
        -   [ ] [The Bit Twiddler Interactive](https://bits.stephan-brumme.com/interactive.html)
        -   [ ] [Bit Hacks (клип)](https://www.youtube.com/watch?v=ZusiKXcz_ac)
        -   [ ] [Practice Operations](https://pconrad.github.io/old_pconrad_cs16/topics/bitOps/)
    -   [ ] 2s and 1s complement
        -   [Binary: Plusses & Minuses (Why We Use Two's Complement) (клип)](https://www.youtube.com/watch?v=lKTsv6iVxV4)
        -   [1s Complement](https://en.wikipedia.org/wiki/Ones%27_complement)
        -   [2s Complement](https://en.wikipedia.org/wiki/Two%27s_complement)
    -   [ ] Преброяване на набор от битове
        -   [4 ways to count bits in a byte (клип)](https://youtu.be/Hzuzo9NJrlc)
        -   [Count Bits](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan)
        -   [How To Count The Number Of Set Bits In a 32 Bit Integer](http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer)
    -   [ ] Размяна на стойности:
        -   [Swap](https://bits.stephan-brumme.com/swap.html)
    -   [ ] Абсолютна стойност:
        -   [Absolute Integer](https://bits.stephan-brumme.com/absInteger.html)

## Дървета

-   ### Дървета - бележки & основи

    -   [ ] [Серия: Дървета (клип)](https://www.coursera.org/lecture/data-structures/trees-95qda)
    -   основна структура на дървото
    -   обхождане
    -   алгоритми за манипулиране
    -   [ ] [BFS(обхождане в ширина) and DFS(обхождане в дълбочина) (клип)](https://www.youtube.com/watch?v=uWL6FJhq5fM)
        -   бележки за BFS:
            -   level order (BFS, using queue)
            -   времева сложност O(n)
            -   пространствена сложност: в най-добрия случай: O(1), в най-лошия случай: O(n/2)=O(n)
        -   бележки за DFS:
            -   времева сложност: O(n)
            -   пространствена сложност:
                в най-добрия случай: O(log n) - средна височина на дървото
                в най-добрия случай: O(n)
            -   inorder (DFS: ляво, self, дясно)
            -   postorder (DFS: ляво, дясно, self)
            -   preorder (DFS: self, ляво, дясно)

-   ### Дървета за двоично търсене: BSTs
    -   [ ] [Преговор над двоични дървета за търсене (клип)](https://www.youtube.com/watch?v=x6At0nzX92o&index=1&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6)
    -   [ ] [Въведение (клип)](https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction)
    -   [ ] [MIT (клип)](https://www.youtube.com/watch?v=9Jry5-82I68)
    -   C/C++:
        -   [ ] [Двоично дърво за търсене - имплементация в C/C++ (клип)](https://www.youtube.com/watch?v=COZK7NATh4k&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=28)
        -   [ ] [BST имплементация - memory allocation in stack and heap (клип)](https://www.youtube.com/watch?v=hWokyBoo0aI&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=29)
        -   [ ] [Намиране на мин. и макс. елемент в двоично дърво за търсенея (клип)](https://www.youtube.com/watch?v=Ut90klNN264&index=30&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)
        -   [ ] [Намиране на височината на двоично дърво (клип)](https://www.youtube.com/watch?v=_pnqMz5nrRs&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=31)
        -   [ ] [Обхождане на двоично дърво - стратегии за обхождане по ширина и по дълбочина (клип)](https://www.youtube.com/watch?v=9RHO6jU--GU&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=32)
        -   [ ] [Двоично дърво: преминаване на порядъка на ниво (клип)](https://www.youtube.com/watch?v=86g8jAQug04&index=33&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)
        -   [ ] [Обхождане на двоично дърво: Preorder, Inorder, Postorder (клип)](https://www.youtube.com/watch?v=gm8DUJJhmY4&index=34&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)
        -   [ ] [Проверка дали двоично дърво е двоично дърво за търсене (клип)](https://www.youtube.com/watch?v=yEwSGhSsT0U&index=35&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)
        -   [ ] [Изтриване на възел от двоично дърво за търсене (клип)](https://www.youtube.com/watch?v=gcULXE7ViZw&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=36)
        -   [ ] [Редовен наследник в двоично дърво (клип)](https://www.youtube.com/watch?v=5cPbNCrdotA&index=37&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)
    -   [ ] Имплементирайте:
        -   [ ] insert // вкарване на стойност в дървото
        -   [ ] get_node_count // вземане на бройката на запазените стойности
        -   [ ] print_values // принтира стойностите в дървото от най-малкия до най-големия
        -   [ ] delete_tree
        -   [ ] is_in_tree // връща true ако дадената стойност съществува в дървото
        -   [ ] get_height // returns the height in nodes (single node's height is 1)
        -   [ ] get_min // връща най-малката стойност, съхранявана в дървото
        -   [ ] get_max // връща най-голямата стойност, съхранявана в дървото
        -   [ ] is_binary_search_tree
        -   [ ] delete_value
        -   [ ] get_successor // връща следващата най-голяма стойност след дадената, -1 ако такава не съществува
